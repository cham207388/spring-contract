# Contract Testing

Testing the API contract between the producer and consumer is a good way to ensure that the API is working as expected. With the help of Spring Cloud Contract, we can easily test the API contract between the producer and consumer without the need to create our own stubs or spin up the producer's service.

## Resources

- [Spring Cloud Contract Reference](https://docs.spring.io/spring-cloud-contract/reference/index.html)
- [Contract test guide](https://spring.io/guides/gs/contract-rest)

## Producer side

This is the service being queried by the consumer either by using WebClient or RestTemplate or RestClient to name a few rest clients. It's also called the server.

### Producer setup

- add `org.springframework.cloud:spring-cloud-starter-contract-verifier` dependency
- write your contracts (**groovy**, kotlin, java, or yaml) in src/contractTest/resources/contracts folder
  - these are test cases
  - `./gradlew build` will likely failed
  - a `build/generated-test-sources/contractTest/ContractVerifierTest` class will be created from the contracts.
- create a `BaseContractTest`
  - this configures wiremock and required for the test generated by the contracts
- update the contract method in the build.gradle file to use the BaseContractTest as in

    ```groovy
    contracts {
      baseClassForTests = 'package-name.BaseContractTest'
    } 
    ```

- open the `ContractVerifierTest` class and extend BaseContractTest
- publishing the stubs to be used by the consumer
  - add publishing method and mvn plugin to the `producer` build.gradle file to publish the stubs to the local maven repository

  ```groovy

    plugins {
      id 'maven-publish'
    }

    publishing {
      publications {
        stubs(MavenPublication) {
            artifactId = "${project.name}"
            artifact ("${buildDir}/libs/${project.name}-${version}-stubs.jar"){
                classifier = 'stubs'
            }
        }
      }
    repositories {
        mavenLocal() // Publishes to the local Maven repository (~/.m2/repository)
    }
  }
  ```

- `./gradlew build`
  - builds the producer along with running the tests, and generate the stubs
- `./gradlw publish`
  - publishes the stubs to the local maven repository
  - make sure that the version is not SNAPSHOT (timestamp in the name instead of SNAPSHOT)
  - I'm using RELEASE version for the producer
  - note the groupId, artifactId, version, and qualifier as they'll required in the consumer side's integration tests class

## Consumer side

This is the service that is calling the producer. It's also called the client.

### Consumer setup

- add `org.springframework.cloud:spring-cloud-starter-contract-stub-runner` dependency
- write your integration tests

  ```java
    @ExtendWith(SpringExtension.class)
    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
    @AutoConfigureStubRunner(
          ids = {"producer-group-id:producer-artifact-id:version:qualifier:14257"},
          stubsMode = StubRunnerProperties.StubsMode.LOCAL)
    public class ConsumerServiceIntegrationTest {
        // your tests here
    }
  ```

- run the tests
- these tests will hit the stubs created by the producer instead of interacting with the producer's service directly. Pretty cool!

## Learning Ideas

- RestClient
- WebClient
- how to use prioritise in WireMock
  - It's a way to make sure that test data are injected accordingly
  - similar endpoints can easily be overridden or not registered
    - /user/post vs /user/post/123
